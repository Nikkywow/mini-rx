# Отчет по реализации MiniRx

## 1. Архитектура системы

Реализованная система состоит из следующих основных компонентов:

### Базовые элементы:
- **Observable** - источник данных, реализующий паттерн "Наблюдатель"
- **Observer** - интерфейс для получения событий (onNext, onError, onComplete)
- **Scheduler** - механизм управления потоками выполнения
- **Disposable** - механизм отмены подписок

### Операторы:
- **map** - преобразование элементов
- **filter** - фильтрация элементов
- **flatMap** - преобразование с созданием новых Observable
- **subscribeOn** - указание потока для выполнения подписки
- **observeOn** - указание потока для обработки элементов

## 2. Принципы работы Schedulers

### Реализованные Schedulers:

1. **IOThreadScheduler**:
   - Использует `CachedThreadPool`
   - Оптимален для I/O операций
   - Создает потоки по мере необходимости
   - Пример использования: сетевые запросы, работа с файлами

2. **ComputationScheduler**:
   - Использует `FixedThreadPool` с размером = количеству ядер
   - Оптимален для CPU-интенсивных задач
   - Пример использования: сложные вычисления

3. **SingleThreadScheduler**:
   - Использует один поток
   - Гарантирует последовательное выполнение
   - Пример использования: обновление UI

### Принцип работы:
- `subscribeOn` определяет, в каком потоке будет выполняться подписка
- `observeOn` определяет, в каком потоке будут обрабатываться элементы

## 3. Реализованные операторы

### Map:
- Принимает `Function<T, R>`
- Преобразует каждый элемент потока
- Сохраняет порядок элементов

### Filter:
- Принимает `Predicate<T>`
- Пропускает только элементы, удовлетворяющие условию
- Не изменяет порядок элементов

### FlatMap:
- Принимает `Function<T, Observable<R>>`
- Позволяет асинхронно обрабатывать элементы
- Может изменять порядок элементов

## 4. Обработка ошибок

Система предоставляет:
1. Централизованную обработку через `onError`
2. Возможность прерывания потока при ошибке
3. Механизм распространения ошибок через цепочку операторов

## 5. Процесс тестирования

### Тестовые сценарии:
1. **Базовые тесты**:
   - Создание Observable
   - Проверка подписки
   - Проверка завершения потока

2. **Тесты операторов**:
   - Проверка преобразования map
   - Проверка фильтрации filter
   - Проверка flatMap

3. **Многопоточные тесты**:
   - Проверка работы subscribeOn
   - Проверка работы observeOn
   - Проверка отмены подписок

4. **Тесты обработки ошибок**:
   - Проверка передачи ошибок
   - Проверка завершения при ошибке

### Использованные инструменты:
- JUnit 5
- Mockito (для мокирования)
- AssertJ (для утверждений)

## 6. Примеры использования

### Пример 1: Базовый pipeline
```java
Observable.create(observer -> {
    observer.onNext(1);
    observer.onNext(2);
    observer.onComplete();
})
.map(x -> x * 2)
.filter(x -> x > 2)
.subscribe(
    System.out::println,
    Throwable::printStackTrace,
    () -> System.out.println("Done")
);
```

### Пример 2: Работа с Schedulers
```java
Observable.create(observer -> {
    // Долгая операция
    observer.onNext(data); 
    observer.onComplete();
})
.subscribeOn(new IOThreadScheduler())
.observeOn(new SingleThreadScheduler())
.subscribe(
    this::updateUI,
    Throwable::printStackTrace
);
```

### Пример 3: Композиция с flatMap
```java
Observable.just(userId)
.flatMap(id -> fetchUserData(id))
.subscribe(
    this::processUserData,
    this::handleError
);
```
